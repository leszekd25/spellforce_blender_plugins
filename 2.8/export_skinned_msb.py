bl_info = {
	"name": "Export skinned SpellForce mesh (.msb/.bor)",
	"description": "Export skinned SpellForce mesh (.msb/.bor)",
	"author": "leszekd25",
	"blender": (2, 80, 0),
	"location": "Import/Export",
	"warning": "totally untested...", # used for warning icon and text in addons panel
	"category": "Import-Export",
}

import bpy
from bpy.props import (
	StringProperty,
	FloatProperty,
	IntProperty,
	BoolProperty,
	EnumProperty,
)
from bpy_extras.io_utils import (
	ImportHelper,
	ExportHelper,
	orientation_helper,
	axis_conversion,
)
from mathutils import *
from struct import unpack, pack
import os.path
	
class SFMap:
	def __init__(self):
		self.texID = -1		  #32 bit
		self.unknown1 = 0	  #8 bit
		self.texUVMode = 0	  #8 bit
		self.unused = 0		  #16 bit
		self.texRenderMode = 0#8 bit
		self.texAlpha = 255	  #8 bit
		self.flag = 7		  #8 bit
		self.depthbias = 0	  #8 bit
		self.tiling = 1.0	#float
		self.texName = ""	  #64 char string
	def get(self):
		charray = []
		for i in range(64):
			if i >= len(self.texName):
				charray.append(0)
			else:
				charray.append(ord(self.texName[i]))
		charray = bytes(charray)
		return pack("1i2B1H4B1f64s", self.texID, self.unknown1, self.texUVMode, self.unused, self.texRenderMode, self.texAlpha, self.flag, self.depthbias, self.tiling, charray)

		
class SFMaterial:
	def __init__(self):
		self.texMain = SFMap()
		self.texSecondary = SFMap()
		self.diffCol = []
		self.emitCol = []
		self.specCol = []
		

def VertIndexOf(l, v):
	for i, _v in enumerate(l):
		if CompareVerts(v, _v):
			return i
	return -1
	
def CompareVerts(v1, v2):	  # [vert_id, vert_normal, vert_uv]
	if (v1[0] != v2[0]):
		return False
	# instead of comparing vectors, compare distances (0.001 is 0.1 angular)
	if(((v1[1][0]-v2[1][0])**2 + (v1[1][1] - v2[1][1])**2 + (v1[1][2] - v2[1][2])**2) ** 0.5) > 0.001:
		return False
	if (v1[2][0] != v2[2][0]) or (v1[2][1] != v2[2][1]):
		return False
	
	return True

# reduces bone count to c, discarding least important bones and padding with 0s when needed
def reduce_bone_count(bi, bw, c):
	while(len(bi)>c):
		i = 0
		min_bw = bw[i]
		for j in range(len(bi)):
			if(bw[j]<min_bw):
				min_bw = bw[j]
				i=j
		del bi[i]
		del bw[i]
	while(len(bi)<c):
		bi.append(0)
		bw.append(0)

# probably could use the Vector class for that...
def normalize(bw):
	s = 0
	for b in bw:
		s+=b
	for i in range(len(bw)):
		bw[i] /= s
		bw[i] = int(bw[i]*255)

# not particularly fast, remaps bone indices to fit the required bone count
def recalculate_bone_indices(bi, bw, bsi_part):
	for i in range(len(bi)):
		bi[i] = (bsi_part.index(bi[i])) if (bw[i] != 0) else (0)
	return bi

def SaveMSBSkinned(context, filepath):
	object = bpy.context.object
	obname=object.name
	mesh = object.data
	armature = object.parent
	skeleton = armature.data
	
	mesh.update()
	mesh.validate()
	
	# generate bone data
	bone_count = len(skeleton.bones)
	bone_pos = []
	bone_rot = []
	bone_parents = []
	
	if bpy.context.active_object:
		bpy.context.active_object.select_set(False)
	armature.select_set(True)
	bpy.context.view_layer.objects.active = armature
	bpy.ops.object.mode_set(mode='EDIT')

	# calculate bone state vectors
	for i in range(bone_count):
		bone = skeleton.edit_bones[i]
		bone_mat = bone.matrix
		if(bone.parent):
			bone_mat = bone.parent.matrix.inverted() @ bone.matrix
			for j, b in enumerate(skeleton.edit_bones):
				if(b == bone.parent):
					bone_parents.append(j)
					break
		else:
			bone_parents.append(-1)
		#print(bone_mat, bone_mat.to_translation(), bone_mat.to_quaternion())
		bone_pos.append(bone_mat.to_translation())
		bone_rot.append(bone_mat.to_quaternion())
	
	# find all vertices for each bone group (needed for skeleton file)
	vlist = []
	for i in range(bone_count):
		vlist.append([])
	for v in mesh.vertices:
		for g in v.groups:
			vlist[g.group].append([v.index, g.weight])
			
	# generate text data
	text_data = []
	text_data.append("// Generated by Blender MSB plugin\n")
	text_data.append("\n")
	text_data.append("[AnimData]\n")
	text_data.append("{\n")
	text_data.append("\tNOB = "+str(bone_count)+"\n")
	text_data.append("\tNOSV = 1\n")
	for i in range(bone_count):
		text_data.append("\t[B"+str(i)+"]\n")
		text_data.append("\t{\n")
		text_data.append("\t\tN = \""+skeleton.bones[i].name+"\"\n")
		text_data.append("\t\tId = "+str(i)+"\n")
		text_data.append("\t\tF = "+str(bone_parents[i])+"\n")
		text_data.append("\t\t[SV0]\n")
		text_data.append("\t\t{\n")
		text_data.append("\t\t\tT = 0.000000\n")
		text_data.append("\t\t\tP = {:f}, {:f}, {:f}\n".format(bone_pos[i][0], bone_pos[i][1], bone_pos[i][2]))
		text_data.append("\t\t\tRre = {:f}\n".format(bone_rot[i].w))
		text_data.append("\t\t\tRim = {:f}, {:f}, {:f}\n".format(bone_rot[i].x, bone_rot[i].y, bone_rot[i].z))
		for j, v in enumerate(vlist[i]):
			text_data.append("\t\t\t[V"+str(j)+"]\n")
			text_data.append("\t\t\t{\n")
			text_data.append("\t\t\t\tI = "+str(v[0])+"\n")
			text_data.append("\t\t\t\tP = 0.000000, 0.000000, 0.000000\n")	 # <- ???
			text_data.append("\t\t\t\tW = {:f}\n".format(v[1]))
			text_data.append("\t\t\t}\n")
			text_data.append("\n")
		text_data.append("\t\t}\n")
		text_data.append("\n")
		text_data.append("\t}\n")
		text_data.append("\n")
	text_data.append("}\n")
	text_data.append("")
	
	filepath2 = filepath.replace(".msb", ".bor")
	borfile = open(filepath2, 'w',)
	borfile.writelines(text_data)
	borfile.close()
	
	# export static mesh
	msbfile = open(filepath.replace(".msb", "")+".msb",'wb')
	modelnum = len(mesh.materials)
	
	bpy.ops.object.mode_set(mode = 'OBJECT')
	mesh.use_auto_smooth = True
	mesh.calc_normals_split()
	
	uv_layer = mesh.uv_layers[mesh.name]
	uvs = []
	for d in uv_layer.data:
		uvs.append(d.uv)
	
	bpy.ops.object.mode_set(mode = 'EDIT')
	# generate vertex map	(vertex ID -> vertex position)
	vertex_map = []
	for v in mesh.vertices:
		vertex_map.append(v.co)
		
	# generate polygon table
	polygons = []							 # vertex ids, vertex normals, vertex uvs, material
	uv_layer = mesh.uv_layers[mesh.name]
	for i in range(len(mesh.polygons)):
		p = mesh.polygons[i]
		t = []
		
		t.append([p.vertices[0], p.vertices[2], p.vertices[1]])
		
		t2 = []
		if mesh.has_custom_normals:
			for j in [0, 2, 1]:
				t2.append(mesh.loops[i*3+j].normal)
		else:
			for j in [0, 2, 1]:
				t2.append(mesh.vertices[t[0][j]].normal)
		t.append(t2)
		
		t3 = []
		for j in [0, 2, 1]:
			t3.append(uvs[i*3+j])
		t.append(t3)
		
		t.append(p.material_index)
		#print("POLYGON", i, t)
		
		polygons.append(t)
	
	bpy.ops.object.mode_set(mode = 'EDIT')
	
	# remove unused materials
	material_map = {}
	for p in polygons:
		material_map[p[3]] = 1
	
	for i in [j for j in range(modelnum)]:	   # not sure if this is needed, maybe `for i in range(modelnum)` would work as well
		if not(i in material_map):
			for p in polygons:
				if(p[3] > i):
					p[3] -= 1
			modelnum -= 1
	
	# split polygons per material
	# each polygon belongs to exactly one material
	polygons_per_material = [[] for i in range(modelnum)]
	for p in polygons:
		polygons_per_material[p[3]].append(p)
	
	# generate vertex buffer for the file, and fix triangle buffer for the file
	vertices_per_material = [[] for i in range(modelnum)]	  # vertex ids, vertex normals, vertex uvs
		
	for i, ppm in enumerate(polygons_per_material):	   
		vpm = vertices_per_material[i]
		for p in ppm:
			for j in range(3):
				v = [p[0][j], p[1][j], p[2][j]]
				#print("VERTEX", v)
				v_ind = VertIndexOf(vpm, v)
				if(v_ind == -1):
					vpm.append(v)
					p[0][j] = len(vpm)-1
				else:
					p[0][j] = v_ind
		
	
	# bounding box
	bbox_per_model = [[10000, 10000, 10000, -10000, -10000, -10000] for i in range(modelnum)]
	bbox_total = [10000, 10000, 10000, -10000, -10000, -10000]
	
	# store saved buffers for later use
	packed_vertices_per_material = [[] for i in range(modelnum)]
	packed_triangles_per_material = [[] for i in range(modelnum)]
	materials = []
	
	# calculate bounding boxes
	for i in range(modelnum):
		for v in vertices_per_material[i]:
			pos = vertex_map[v[0]]
			bbox_per_model[i][0] = min(bbox_per_model[i][0], pos[0])
			bbox_per_model[i][1] = min(bbox_per_model[i][1], pos[1])
			bbox_per_model[i][2] = min(bbox_per_model[i][2], pos[2])
			bbox_per_model[i][3] = max(bbox_per_model[i][3], pos[0])
			bbox_per_model[i][4] = max(bbox_per_model[i][4], pos[1])
			bbox_per_model[i][5] = max(bbox_per_model[i][5], pos[2])
			
	for i in range(modelnum):
		bbox_total[0] = min(bbox_total[0], bbox_per_model[i][0])
		bbox_total[1] = min(bbox_total[1], bbox_per_model[i][1])
		bbox_total[2] = min(bbox_total[2], bbox_per_model[i][2])
		bbox_total[3] = max(bbox_total[3], bbox_per_model[i][3])
		bbox_total[4] = max(bbox_total[4], bbox_per_model[i][4])
		bbox_total[5] = max(bbox_total[5], bbox_per_model[i][5])
		
	# write header
	outdata = pack("BBHBB", 0, 2, modelnum, 0, 0)
	msbfile.write(outdata)
	
	for i in range(modelnum):
		outdata2 = pack("2b4H", 0, 2, len(vertices_per_material[i]), 0, len(polygons_per_material[i]), 0)
		msbfile.write(outdata2)
		
		for k, v in enumerate(vertices_per_material[i]):
			pos = vertex_map[v[0]]
			normal = v[1]
			col = [255, 255, 255, 255]
			uv = v[2]
			ind = v[0]
			packed_vertices_per_material[i].append([pos, normal, col, uv, ind])
			outdata3 = pack('6f4B2fI', pos[0], pos[1], pos[2], normal[0], normal[1], normal[2], col[0], col[1], col[2], col[3], uv[0], 1-uv[1], ind)
			msbfile.write(outdata3)
		
		for k, f in enumerate(polygons_per_material[i]):
			packed_triangles_per_material[i].append([f[0][0], f[0][1], f[0][2]])
			outdata4 = pack("4H", f[0][0], f[0][1], f[0][2], f[3])
			msbfile.write(outdata4)
		
		# handle materials
		material = SFMaterial()
		diffuse_color = mesh.materials[i].node_tree.nodes.get('Diffuse Color').outputs[0].default_value
		material.diffCol = [int(diffuse_color[2]*255), int(diffuse_color[1]*255), int(diffuse_color[0]*255), 0]
		specular_color = mesh.materials[i].node_tree.nodes.get('Specular Color').outputs[0].default_value
		material.specCol = [int(specular_color[2]*255), int(specular_color[1]*255), int(specular_color[0]*255), 0]
		material.emitCol = [0, 0, 0, 0]
		if mesh.materials[i].get('SFRenderMode') is not None:
			material.texMain.texRenderMode = mesh.materials[i]["SFRenderMode"]
		else:
			material.texMain.texRenderMode = 0
		if mesh.materials[i].get("SFFlags") is not None:
			material.texMain.flag = mesh.materials[i]["SFFlags"]
		else:
			material.texMain.flag = 7
		material.texMain.texName = mesh.materials[i].node_tree.nodes.get('Image Texture').image.name
		materials.append(material)
		# write to file
		msbfile.write(pack("2B", 0, 2))
		msbfile.write(material.texMain.get())
		msbfile.write(material.texSecondary.get())
		msbfile.write(pack("4B", material.diffCol[0], material.diffCol[1], material.diffCol[2], material.diffCol[3]))
		msbfile.write(pack("4B", material.emitCol[0], material.emitCol[1], material.emitCol[2], material.emitCol[3]))
		msbfile.write(pack("4B", material.specCol[0], material.specCol[1], material.specCol[2], material.specCol[3]))
		msbfile.write(pack("6f", bbox_per_model[i][0], bbox_per_model[i][1], bbox_per_model[i][2], bbox_per_model[i][3], bbox_per_model[i][4], bbox_per_model[i][5]))
		msbfile.write(pack("2f", 1.0, 0.0))
	#write footer
	
	msbfile.write(pack("6f", bbox_total[0],bbox_total[1],bbox_total[2],bbox_total[3],bbox_total[4],bbox_total[5]))
	msbfile.close()
	
	# SKIN+BSI GENERATION
	
	# generate list of bones per vertex
	bones_per_vertex = [[] for i in range(len(mesh.vertices))]
	for i, g in enumerate(vlist):	# i = bone index
		for v in g:	 # v = [vertex id, bone weight]
			bones_per_vertex[v[0]].append([i, v[1]])  # bones_per_vertex[v_id] = [[bone0, weight0], [bone1, weight1], ...]
	
	# find all bones used per material
	bones_per_material = [set() for i in range(modelnum)]
	for i in range(modelnum):
		for j, v in enumerate(packed_vertices_per_material[i]):
			#print(j, v)
			for w in bones_per_vertex[v[4]]:
				bones_per_material[i].add(w[0])
	
	# begin generating BSI
	# bsi will be splitting meshbuffers only if bonecount per meshbuffer > 20
	# how to split a meshbuffer:
	# 1. select first unselected triangle
	# 2. go down the list of triangles, selecting them and remembering all bones used by the triangle until their count reaches 20
	# 3. select all remaining triangles which only use marked bones
	# 4. generate new meshbuffer for each such set of triangles
	# 5. repeat until no more triangles
	# not a perfect algorithm, but it will get the work done, though i wonder how would it look on aryn skin for example
	# SpellForce does this much better, gotta investigate
	bsi = []
	batch_count = 0
	skin_packed_triangles_per_batch = []  # [material index, [triangles]]
	skin_packed_vertices_per_batch = []	  # [vertices]					   vertices contain bone info! bone info per vertex found in bones_per_vertex
	skin_packed_materials_per_batch = []
	
	for i, bpm in enumerate(bones_per_material):   # i - material index
		# vertex preprocessing
		for v in packed_vertices_per_material[i]:  # result: [pos, normal, bone_ind, uv, ind, bone_weight]
			# calculate bones
			bone_ind = []
			bone_ws = []
			for b in bones_per_vertex[v[4]]:
				bone_ind.append(b[0])
				bone_ws.append(b[1])
			reduce_bone_count(bone_ind, bone_ws, 3)
			normalize(bone_ws)
			v[2] = bone_ind
			v.append(bone_ws)
			
		# generating skin batches and BSI
		if(len(bones_per_material[i]) <= 20):
			# dont split, just pass data from packed meshbuffers
			# but first, final bone processing for BSI
			bsi_part = []
			for b in bpm:
				bsi_part.append(b)
				
			skin_packed_vertices_per_batch.append([])
			for v in packed_vertices_per_material[i]:
				v2 = [[v[0][0], v[0][1], v[0][2]], [v[1][0], v[1][1], v[1][2]], [v[2][0], v[2][1], v[2][2]], [v[3][0], v[3][1]], v[4], [v[5][0], v[5][1], v[5][2]]] # copy vertex
				v2[2] = recalculate_bone_indices(v2[2], v2[5], bsi_part)
				skin_packed_vertices_per_batch[-1].append(v2)
				
			skin_packed_triangles_per_batch.append([i, []])
			for t in packed_triangles_per_material[i]:
				skin_packed_triangles_per_batch[-1][1].append(t)
				
			skin_packed_materials_per_batch.append(materials[i])
			
			bsi.append(bsi_part)
			batch_count += 1
		else:
			# ugh
			# 0. generate data required for algorithm to work
			triangles_batch_index = [-1 for i in range(len(packed_triangles_per_material[i]))]	# -1 - unselected yet, x - selected in batch x
			triangles_selected_count = 0
			current_batch = 0
			bones_per_batch = []
			while True:
				first_triangle = -1
				# 1. select first unselected triangle
				for j in range(len(triangles_batch_index)):
					if(triangles_batch_index[j] == -1):
						first_triangle = j
						break
				# if triangle not found, stop here
				if(first_triangle == -1):
					break
				# 2. go down the list of triangles, selecting them and remembering all bones used by the triangle until their count reaches 20
				# only select triangles if its possible (so the bone count <= 20 at all times)
				# 3. select all remaining triangles which only use marked bones
				batch_bones = set()
				for j in range(first_triangle, len(packed_triangles_per_material[i])):
					t = packed_triangles_per_material[i][j]
					# get bones on this triangle
					current_triangle_bones = set()
					for k in range(3):
						v = packed_vertices_per_material[i][t[k]]
						for l in range(3):
							if v[5][l] != 0:
								current_triangle_bones.add(v[2][l])
					if(len(batch_bones | current_triangle_bones) <= 20):
						triangles_selected_count += 1
						triangles_batch_index[j] = current_batch
						batch_bones = batch_bones | current_triangle_bones
				bones_per_batch.append([])
				for b in batch_bones:
					bones_per_batch[-1].append(b)
				current_batch += 1
			
			# we have now triangle batches - all thats left is to generate BSI and meshbuffers
			for j in range(current_batch):
				bsi_part = []
				for b in bones_per_batch[j]:
					bsi_part.append(b)
					
				vind_used = set()	   # indices in packed_vertices_per_material[i] used in this batch
				for k, p in enumerate(triangles_batch_index):
					if p == j:
						t = packed_triangles_per_material[i][k]
						for l in range(3):
							vind_used.add(t[l])
				vind_used = list(vind_used)
				vind_used.sort()
				
				vind_used_inverted = {}	   # if vind_used[X] = I, then vind_used_inverted[I] = X
				for k, p in enumerate(vind_used):
					vind_used_inverted[p] = k
				
				skin_packed_vertices_per_batch.append([])
				for k, v in enumerate(packed_vertices_per_material[i]):
					if k in vind_used_inverted:
						v2 = [[v[0][0], v[0][1], v[0][2]], [v[1][0], v[1][1], v[1][2]], [v[2][0], v[2][1], v[2][2]], [v[3][0], v[3][1]], v[4], [v[5][0], v[5][1], v[5][2]]] # copy vertex
						v2[2] = recalculate_bone_indices(v2[2], v2[5], bsi_part)
						skin_packed_vertices_per_batch[-1].append(v2)
				
				skin_packed_triangles_per_batch.append([i, []])
				for k, p in enumerate(triangles_batch_index):
					if p == j:
						t = packed_triangles_per_material[i][k]
						t2 = [vind_used_inverted[t[0]], vind_used_inverted[t[1]], vind_used_inverted[t[2]]]
						skin_packed_triangles_per_batch[-1][1].append(t2)
				
				skin_packed_materials_per_batch.append(materials[i])
				
				bsi.append(bsi_part)
				batch_count += 1
	
	# generate BSI file
	filepath3 = filepath.replace(".msb", ".bsi")
	bsifile = open(filepath3, 'wb',)
	
	bsifile.write(pack("I", len(bsi)))
	for i, bsi_part in enumerate(bsi):
		bsifile.write(pack("II", skin_packed_triangles_per_batch[i][0], len(bsi_part)))
		for j, b in enumerate(bsi_part):
			bsifile.write(pack("I", b))
	
	bsifile.close()
	
	batch_count = len(bsi)
	
	# calculate bounding boxes for the parts of skin
	bbox_per_model = [[10000, 10000, 10000, -10000, -10000, -10000] for i in range(batch_count)]
	
	for i in range(batch_count):
		for v in skin_packed_vertices_per_batch[i]:
			pos = v[0]
			bbox_per_model[i][0] = min(bbox_per_model[i][0], pos[0])
			bbox_per_model[i][1] = min(bbox_per_model[i][1], pos[1])
			bbox_per_model[i][2] = min(bbox_per_model[i][2], pos[2])
			bbox_per_model[i][3] = max(bbox_per_model[i][3], pos[0])
			bbox_per_model[i][4] = max(bbox_per_model[i][4], pos[1])
			bbox_per_model[i][5] = max(bbox_per_model[i][5], pos[2])
	
	# generate skin .msb file
	filepath4 = filepath.replace(".msb", "")+"_SKIN.msb"
	sknfile = open(filepath4, 'wb',)
	
	# write header
	outdata = pack("BBHBB", 0, 2, batch_count, 0, 0)
	sknfile.write(outdata)

	for i in range(batch_count):
		# write header
		outdata2 = pack("2b4H", 0, 2, len(skin_packed_vertices_per_batch[i]), 0, len(skin_packed_triangles_per_batch[i][1]), 0)
		sknfile.write(outdata2)
		
		for v in skin_packed_vertices_per_batch[i]:
			pos = v[0]
			normal = v[1]
			boneweight = v[5]
			uv = v[3]
			boneind = v[2]
			outdata3 = pack('6f4B2f4B', pos[0], pos[1], pos[2], normal[0], normal[1], normal[2], boneweight[2], boneweight[1], boneweight[0], 0, uv[0], 1-uv[1], boneind[2], boneind[1], boneind[0], 0)
			sknfile.write(outdata3)
			# write to file
		
		mat_ind = skin_packed_triangles_per_batch[i][0]
		for t in skin_packed_triangles_per_batch[i][1]:
			outdata4 = pack("4H", t[0], t[1], t[2], mat_ind)
			sknfile.write(outdata4)
		
		material = skin_packed_materials_per_batch[i]
		sknfile.write(pack("2B", 0, 2))
		sknfile.write(material.texMain.get())
		sknfile.write(material.texSecondary.get())
		sknfile.write(pack("4B", material.diffCol[0], material.diffCol[1], material.diffCol[2], material.diffCol[3]))
		sknfile.write(pack("4B", material.emitCol[0], material.emitCol[1], material.emitCol[2], material.emitCol[3]))
		sknfile.write(pack("4B", material.specCol[0], material.specCol[1], material.specCol[2], material.specCol[3]))
		sknfile.write(pack("6f", bbox_per_model[i][0], bbox_per_model[i][1], bbox_per_model[i][2], bbox_per_model[i][3], bbox_per_model[i][4], bbox_per_model[i][5]))
		sknfile.write(pack("2f", 1.0, 0.0))
	#write footer
	
	sknfile.write(pack("6f", bbox_total[0],bbox_total[1],bbox_total[2],bbox_total[3],bbox_total[4],bbox_total[5]))
	sknfile.close()
	
	return 0


class ExportSkinnedMSB(bpy.types.Operator, ExportHelper):
	"""Object Cursor Array"""
	bl_idname = "export.msb_skinned"
	bl_label = "Export SpellForce skinned mesh (.msb)"
	bl_options = {'REGISTER'}
	
	filepath: StringProperty(
		name="Output mesh",
		subtype='FILE_PATH'
		)

	filename_ext = ".msb"

	filter_glob: StringProperty(
			default="*.msb",
			options={'HIDDEN'},
			)
	
	@classmethod
	def poll(cls, context):
		obj = context.object
		return obj and obj.type == 'MESH' and obj.parent

	def execute(self, context):
		if SaveMSBSkinned(context, self.filepath) == 0:
			return {'FINISHED'}
		return {'CANCELLED'}



def menu_func(self, context):
	self.layout.operator(ExportSkinnedMSB.bl_idname, text="Export SpellForce skinned mesh (.msb)")


def register():
	bpy.utils.register_class(ExportSkinnedMSB)
	bpy.types.TOPBAR_MT_file_export.append(menu_func)

def unregister():
	bpy.utils.unregister_class(ExportSkinnedMSB)
	bpy.types.TOPBAR_MT_file_export.remove(menu_func)


if __name__ == "__main__":
	register()